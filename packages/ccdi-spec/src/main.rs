use std::fs::File;
use std::io;
use std::net::Ipv4Addr;
use std::path::PathBuf;

use actix_web::middleware::Logger;
use actix_web::rt;
use actix_web::web::Data;
use actix_web::App;
use actix_web::HttpServer;
use clap::Parser;
use clap::Subcommand;
use log::info;
use log::LevelFilter;
use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

use ccdi_models as models;
use ccdi_openapi as api;
use ccdi_server as server;

use api::Api;

use server::routes::metadata;
use server::routes::sample;
use server::routes::subject;

mod utils;

use utils::markdown;

const ERROR_EXIT_CODE: i32 = 1;

/// An error related to the main program.
#[derive(Debug)]
pub enum Error {
    /// A file already exists at the specified location.
    FileExists(PathBuf),

    /// An input/output error.
    IoError(io::Error),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::FileExists(path) => write!(f, "file already exists: {}", path.display()),
            Error::IoError(err) => write!(f, "i/o error: {err}"),
        }
    }
}

impl std::error::Error for Error {}

#[derive(Debug, Parser)]
pub struct GenerateArgs {
    /// A path to write the output to.
    #[arg(short = 'o')]
    output: Option<PathBuf>,

    /// Whether to force the output file to be overwritten (if it exists).
    #[arg(short, long)]
    force: bool,
}

#[derive(Debug, Parser)]
pub struct ServeArgs {
    /// Number of subjects for the server to generate.
    #[arg(short = 'n', default_value_t = 100)]
    number_of_subjects: usize,

    /// A path to write the output to.
    #[arg(short = 'p', default_value_t = 8000)]
    port: u16,
}

#[derive(Clone, Debug, clap::ValueEnum)]
pub enum WikiEntity {
    /// A subject.
    Subject,

    /// A sample.
    Sample,
}

#[derive(Debug, Parser)]
pub struct WikiArgs {
    /// The API entity for which to generate a wiki page.
    entity: WikiEntity,
}

#[derive(Debug, Subcommand)]
pub enum Command {
    /// Generate the OpenAPI specification as YAML.
    Generate(GenerateArgs),

    /// Runs the test server.
    Serve(ServeArgs),

    /// Generates the documentation for a wiki page covering an API entity.
    Wiki(WikiArgs),
}

// A program to prepare the Childhood Cancer Data Initiative OpenAPI
/// specification from (a) a base specification and (b) an autogenerated
/// specification using TypeScript.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about)]
struct Args {
    /// The subcommand to execute.
    #[command(subcommand)]
    command: Command,
}

fn get_output(path: Option<PathBuf>, force: bool) -> Result<Box<dyn std::io::Write>, Error> {
    match path {
        Some(path) => {
            if !force && path.exists() {
                return Err(Error::FileExists(path));
            }

            File::create(path)
                .map(|file| Box::new(file) as Box<dyn std::io::Write>)
                .map_err(Error::IoError)
        }
        None => Ok(Box::new(std::io::stdout())),
    }
}

fn inner() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    env_logger::builder()
        .filter_level(LevelFilter::Debug)
        .init();

    match args.command {
        Command::Generate(args) => {
            let api = Api::openapi();
            let mut writer = get_output(args.output, args.force)?;
            write!(writer, "{}", api.to_yaml()?)?;
        }
        Command::Serve(args) => {
            info!("Starting server at http://localhost:{}", args.port);

            rt::System::new().block_on(
                HttpServer::new(move || {
                    let subjects = Data::new(subject::Store::random(args.number_of_subjects));
                    let samples = Data::new(sample::Store::random(args.number_of_subjects));

                    App::new()
                        .wrap(Logger::default())
                        .configure(subject::configure(subjects))
                        .configure(sample::configure(samples))
                        .configure(metadata::configure())
                        .service(
                            SwaggerUi::new("/swagger-ui/{_:.*}")
                                .url("/api-docs/openapi.json", Api::openapi()),
                        )
                })
                .bind((Ipv4Addr::UNSPECIFIED, args.port))?
                .run(),
            )?;
        }
        Command::Wiki(args) => {
            let fields = match args.entity {
                WikiEntity::Subject => {
                    models::metadata::field::description::harmonized::subject::get_field_descriptions()
                }
                WikiEntity::Sample => {
                    models::metadata::field::description::harmonized::sample::get_field_descriptions(
                    )
                }
            };

            for field in fields {
                let section = markdown::Section::from(field);
                println!("{}\n", section);
            }
        }
    }

    Ok(())
}

fn main() {
    match inner() {
        Ok(_) => {}
        Err(err) => {
            eprintln!("error: {err}");
            std::process::exit(ERROR_EXIT_CODE);
        }
    }
}
