#![warn(rust_2018_idioms)]
#![warn(rust_2021_compatibility)]
#![warn(missing_debug_implementations)]
#![deny(rustdoc::broken_intra_doc_links)]

use std::fs::File;
use std::io;
use std::path::PathBuf;

use clap::Parser;

use ccdi_spec_tool as ccdi;

use ccdi::yaml::Reader;
use ccdi::yaml::Repository;

const ERROR_EXIT_CODE: i32 = 1;

const TEMPLATE_KEYS: &[&str] = &["openapi", "info", "externalDocs", "servers", "tags"];
const GENERATED_KEYS: &[&str] = &["paths", "components"];

const TAG_ASSIGNMENTS: &[(&str, &str)] = &[
    ("/subject", "Subject")
];

/// An error related to the main program.
#[derive(Debug)]
pub enum Error {
    /// A file already exists at the specified location.
    FileExists(PathBuf),

    /// An input/output error.
    IoError(io::Error),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::FileExists(path) => write!(f, "file already exists: {}", path.display()),
            Error::IoError(err) => write!(f, "i/o error: {err}"),
        }
    }
}

impl std::error::Error for Error {}

/// A program to prepare the Childhood Cancer Data Initiative OpenAPI
/// specification from (a) a base specification and (b) an autogenerated
/// specification using TypeScript.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about)]
struct Args {
    /// A path to the template YAML.
    template: PathBuf,

    /// A path to the TypeScript-generated YAML.
    generated: PathBuf,

    /// A path to write the output to.
    #[arg(short = 'o')]
    output: Option<PathBuf>,

    /// Whether to force the output file to be overwritten (if it exists).
    #[arg(short, long)]
    force: bool
}

fn get_output(path: Option<PathBuf>, force: bool) -> Result<Box<dyn std::io::Write>, Error> {
    match path {
        Some(path) => {
            if !force && path.exists() {
                return Err(Error::FileExists(path));
            }

            File::create(path)
            .map(|file| Box::new(file) as Box<dyn std::io::Write>)
            .map_err(Error::IoError)
        },
        None => Ok(Box::new(std::io::stdout()))
    }
}

fn inner() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let writer = get_output(args.output, args.force)?;

    let template = Reader::try_from(args.template.as_ref())?;
    let generated = Reader::try_from(args.generated.as_ref())?;

    let mut result = Repository::default();

    for key in TEMPLATE_KEYS {
        result.pull(key, &template)?;
    }

    for key in GENERATED_KEYS {
        result.pull(key, &generated)?;
    }

    for (prefix, tag) in TAG_ASSIGNMENTS {
        result.assign_tag_for_path_prefix(prefix, tag)?;
    }

    result.write(writer)?;

    Ok(())
}

pub fn main() {
    match inner() {
        Ok(_) => {}
        Err(err) => {
            eprintln!("error: {err}");
            std::process::exit(ERROR_EXIT_CODE);
        }
    }
}
